# Generated from SION.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\27")
        buf.write("y\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t")
        buf.write("\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\3\2\3\2\3")
        buf.write("\2\5\2(\n\2\3\3\3\3\3\3\3\3\3\3\3\3\5\3\60\n\3\3\4\3\4")
        buf.write("\3\4\7\4\65\n\4\f\4\16\48\13\4\3\5\3\5\3\5\3\5\3\5\3\5")
        buf.write("\3\5\5\5A\n\5\3\6\3\6\3\6\7\6F\n\6\f\6\16\6I\13\6\3\7")
        buf.write("\3\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\5\bV\n\b\3\t")
        buf.write("\5\tY\n\t\3\t\3\t\3\n\5\n^\n\n\3\n\3\n\3\13\3\13\5\13")
        buf.write("d\n\13\3\f\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20\3\20\3")
        buf.write("\21\3\21\3\21\5\21s\n\21\3\21\3\21\3\22\3\22\3\22\2\2")
        buf.write("\23\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"\2\3\3\2")
        buf.write("\20\23\2w\2\'\3\2\2\2\4/\3\2\2\2\6\61\3\2\2\2\b@\3\2\2")
        buf.write("\2\nB\3\2\2\2\fJ\3\2\2\2\16U\3\2\2\2\20X\3\2\2\2\22]\3")
        buf.write("\2\2\2\24c\3\2\2\2\26e\3\2\2\2\30g\3\2\2\2\32i\3\2\2\2")
        buf.write("\34k\3\2\2\2\36m\3\2\2\2 o\3\2\2\2\"v\3\2\2\2$(\5\16\b")
        buf.write("\2%(\5\4\3\2&(\5\b\5\2\'$\3\2\2\2\'%\3\2\2\2\'&\3\2\2")
        buf.write("\2(\3\3\2\2\2)*\7\6\2\2*\60\7\7\2\2+,\7\6\2\2,-\5\6\4")
        buf.write("\2-.\7\7\2\2.\60\3\2\2\2/)\3\2\2\2/+\3\2\2\2\60\5\3\2")
        buf.write("\2\2\61\66\5\2\2\2\62\63\7\b\2\2\63\65\5\2\2\2\64\62\3")
        buf.write("\2\2\2\658\3\2\2\2\66\64\3\2\2\2\66\67\3\2\2\2\67\7\3")
        buf.write("\2\2\28\66\3\2\2\29:\7\6\2\2:;\5\n\6\2;<\7\7\2\2<A\3\2")
        buf.write("\2\2=>\7\6\2\2>?\7\n\2\2?A\7\7\2\2@9\3\2\2\2@=\3\2\2\2")
        buf.write("A\t\3\2\2\2BG\5\f\7\2CD\7\b\2\2DF\5\f\7\2EC\3\2\2\2FI")
        buf.write("\3\2\2\2GE\3\2\2\2GH\3\2\2\2H\13\3\2\2\2IG\3\2\2\2JK\5")
        buf.write("\2\2\2KL\7\n\2\2LM\5\2\2\2M\r\3\2\2\2NV\5 \21\2OV\5\36")
        buf.write("\20\2PV\5\20\t\2QV\5\22\n\2RV\5\"\22\2SV\5\24\13\2TV\5")
        buf.write("\32\16\2UN\3\2\2\2UO\3\2\2\2UP\3\2\2\2UQ\3\2\2\2UR\3\2")
        buf.write("\2\2US\3\2\2\2UT\3\2\2\2V\17\3\2\2\2WY\7\5\2\2XW\3\2\2")
        buf.write("\2XY\3\2\2\2YZ\3\2\2\2Z[\5\34\17\2[\21\3\2\2\2\\^\7\5")
        buf.write("\2\2]\\\3\2\2\2]^\3\2\2\2^_\3\2\2\2_`\7\24\2\2`\23\3\2")
        buf.write("\2\2ad\5\26\f\2bd\5\30\r\2ca\3\2\2\2cb\3\2\2\2d\25\3\2")
        buf.write("\2\2ef\7\r\2\2f\27\3\2\2\2gh\7\16\2\2h\31\3\2\2\2ij\7")
        buf.write("\f\2\2j\33\3\2\2\2kl\t\2\2\2l\35\3\2\2\2mn\7\17\2\2n\37")
        buf.write("\3\2\2\2or\7\3\2\2ps\5\22\n\2qs\5\20\t\2rp\3\2\2\2rq\3")
        buf.write("\2\2\2st\3\2\2\2tu\7\4\2\2u!\3\2\2\2vw\7\25\2\2w#\3\2")
        buf.write("\2\2\f\'/\66@GUX]cr")
        return buf.getvalue()


class SIONParser ( Parser ):

    grammarFileName = "SION.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.Date('", "')'", "'-'", "'['", "']'", 
                     "','", "'\"'", "':'", "'.'", "'nil'", "'true'", "'false'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "SI_minus", 
                      "SI_lsb", "SI_rsb", "SI_comma", "SI_quote", "SI_colon", 
                      "SI_dot", "SI_nil", "SI_true", "SI_false", "SI_data", 
                      "SI_bin", "SI_oct", "SI_decimal", "SI_hex", "SI_double", 
                      "SI_string_literal", "SI_ws", "SI_comment" ]

    RULE_si_self = 0
    RULE_si_array = 1
    RULE_si_array_items = 2
    RULE_si_dict = 3
    RULE_si_dict_pairs = 4
    RULE_si_dict_pair = 5
    RULE_si_literal = 6
    RULE_si_ints = 7
    RULE_si_doubles = 8
    RULE_si_bool = 9
    RULE_si_true = 10
    RULE_si_false = 11
    RULE_si_nil = 12
    RULE_si_int = 13
    RULE_si_data = 14
    RULE_si_date = 15
    RULE_si_string = 16

    ruleNames =  [ "si_self", "si_array", "si_array_items", "si_dict", "si_dict_pairs", 
                   "si_dict_pair", "si_literal", "si_ints", "si_doubles", 
                   "si_bool", "si_true", "si_false", "si_nil", "si_int", 
                   "si_data", "si_date", "si_string" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    SI_minus=3
    SI_lsb=4
    SI_rsb=5
    SI_comma=6
    SI_quote=7
    SI_colon=8
    SI_dot=9
    SI_nil=10
    SI_true=11
    SI_false=12
    SI_data=13
    SI_bin=14
    SI_oct=15
    SI_decimal=16
    SI_hex=17
    SI_double=18
    SI_string_literal=19
    SI_ws=20
    SI_comment=21

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class Si_selfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def si_literal(self):
            return self.getTypedRuleContext(SIONParser.Si_literalContext,0)


        def si_array(self):
            return self.getTypedRuleContext(SIONParser.Si_arrayContext,0)


        def si_dict(self):
            return self.getTypedRuleContext(SIONParser.Si_dictContext,0)


        def getRuleIndex(self):
            return SIONParser.RULE_si_self

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_self" ):
                return visitor.visitSi_self(self)
            else:
                return visitor.visitChildren(self)




    def si_self(self):

        localctx = SIONParser.Si_selfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_si_self)
        try:
            self.state = 37
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 34
                self.si_literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 35
                self.si_array()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 36
                self.si_dict()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_arrayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_lsb(self):
            return self.getToken(SIONParser.SI_lsb, 0)

        def SI_rsb(self):
            return self.getToken(SIONParser.SI_rsb, 0)

        def si_array_items(self):
            return self.getTypedRuleContext(SIONParser.Si_array_itemsContext,0)


        def getRuleIndex(self):
            return SIONParser.RULE_si_array

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_array" ):
                return visitor.visitSi_array(self)
            else:
                return visitor.visitChildren(self)




    def si_array(self):

        localctx = SIONParser.Si_arrayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_si_array)
        try:
            self.state = 45
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 39
                self.match(SIONParser.SI_lsb)
                self.state = 40
                self.match(SIONParser.SI_rsb)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 41
                self.match(SIONParser.SI_lsb)
                self.state = 42
                self.si_array_items()
                self.state = 43
                self.match(SIONParser.SI_rsb)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_array_itemsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def si_self(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SIONParser.Si_selfContext)
            else:
                return self.getTypedRuleContext(SIONParser.Si_selfContext,i)


        def SI_comma(self, i:int=None):
            if i is None:
                return self.getTokens(SIONParser.SI_comma)
            else:
                return self.getToken(SIONParser.SI_comma, i)

        def getRuleIndex(self):
            return SIONParser.RULE_si_array_items

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_array_items" ):
                return visitor.visitSi_array_items(self)
            else:
                return visitor.visitChildren(self)




    def si_array_items(self):

        localctx = SIONParser.Si_array_itemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_si_array_items)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 47
            self.si_self()
            self.state = 52
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SIONParser.SI_comma:
                self.state = 48
                self.match(SIONParser.SI_comma)
                self.state = 49
                self.si_self()
                self.state = 54
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_dictContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_lsb(self):
            return self.getToken(SIONParser.SI_lsb, 0)

        def si_dict_pairs(self):
            return self.getTypedRuleContext(SIONParser.Si_dict_pairsContext,0)


        def SI_rsb(self):
            return self.getToken(SIONParser.SI_rsb, 0)

        def SI_colon(self):
            return self.getToken(SIONParser.SI_colon, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_dict

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_dict" ):
                return visitor.visitSi_dict(self)
            else:
                return visitor.visitChildren(self)




    def si_dict(self):

        localctx = SIONParser.Si_dictContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_si_dict)
        try:
            self.state = 62
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 55
                self.match(SIONParser.SI_lsb)
                self.state = 56
                self.si_dict_pairs()
                self.state = 57
                self.match(SIONParser.SI_rsb)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 59
                self.match(SIONParser.SI_lsb)
                self.state = 60
                self.match(SIONParser.SI_colon)
                self.state = 61
                self.match(SIONParser.SI_rsb)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_dict_pairsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def si_dict_pair(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SIONParser.Si_dict_pairContext)
            else:
                return self.getTypedRuleContext(SIONParser.Si_dict_pairContext,i)


        def SI_comma(self, i:int=None):
            if i is None:
                return self.getTokens(SIONParser.SI_comma)
            else:
                return self.getToken(SIONParser.SI_comma, i)

        def getRuleIndex(self):
            return SIONParser.RULE_si_dict_pairs

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_dict_pairs" ):
                return visitor.visitSi_dict_pairs(self)
            else:
                return visitor.visitChildren(self)




    def si_dict_pairs(self):

        localctx = SIONParser.Si_dict_pairsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_si_dict_pairs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64
            self.si_dict_pair()
            self.state = 69
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SIONParser.SI_comma:
                self.state = 65
                self.match(SIONParser.SI_comma)
                self.state = 66
                self.si_dict_pair()
                self.state = 71
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_dict_pairContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def si_self(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SIONParser.Si_selfContext)
            else:
                return self.getTypedRuleContext(SIONParser.Si_selfContext,i)


        def SI_colon(self):
            return self.getToken(SIONParser.SI_colon, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_dict_pair

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_dict_pair" ):
                return visitor.visitSi_dict_pair(self)
            else:
                return visitor.visitChildren(self)




    def si_dict_pair(self):

        localctx = SIONParser.Si_dict_pairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_si_dict_pair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.si_self()
            self.state = 73
            self.match(SIONParser.SI_colon)
            self.state = 74
            self.si_self()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def si_date(self):
            return self.getTypedRuleContext(SIONParser.Si_dateContext,0)


        def si_data(self):
            return self.getTypedRuleContext(SIONParser.Si_dataContext,0)


        def si_ints(self):
            return self.getTypedRuleContext(SIONParser.Si_intsContext,0)


        def si_doubles(self):
            return self.getTypedRuleContext(SIONParser.Si_doublesContext,0)


        def si_string(self):
            return self.getTypedRuleContext(SIONParser.Si_stringContext,0)


        def si_bool(self):
            return self.getTypedRuleContext(SIONParser.Si_boolContext,0)


        def si_nil(self):
            return self.getTypedRuleContext(SIONParser.Si_nilContext,0)


        def getRuleIndex(self):
            return SIONParser.RULE_si_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_literal" ):
                return visitor.visitSi_literal(self)
            else:
                return visitor.visitChildren(self)




    def si_literal(self):

        localctx = SIONParser.Si_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_si_literal)
        try:
            self.state = 83
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 76
                self.si_date()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 77
                self.si_data()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 78
                self.si_ints()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 79
                self.si_doubles()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 80
                self.si_string()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 81
                self.si_bool()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 82
                self.si_nil()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_intsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def si_int(self):
            return self.getTypedRuleContext(SIONParser.Si_intContext,0)


        def SI_minus(self):
            return self.getToken(SIONParser.SI_minus, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_ints

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_ints" ):
                return visitor.visitSi_ints(self)
            else:
                return visitor.visitChildren(self)




    def si_ints(self):

        localctx = SIONParser.Si_intsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_si_ints)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SIONParser.SI_minus:
                self.state = 85
                self.match(SIONParser.SI_minus)


            self.state = 88
            self.si_int()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_doublesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_double(self):
            return self.getToken(SIONParser.SI_double, 0)

        def SI_minus(self):
            return self.getToken(SIONParser.SI_minus, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_doubles

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_doubles" ):
                return visitor.visitSi_doubles(self)
            else:
                return visitor.visitChildren(self)




    def si_doubles(self):

        localctx = SIONParser.Si_doublesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_si_doubles)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SIONParser.SI_minus:
                self.state = 90
                self.match(SIONParser.SI_minus)


            self.state = 93
            self.match(SIONParser.SI_double)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_boolContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def si_true(self):
            return self.getTypedRuleContext(SIONParser.Si_trueContext,0)


        def si_false(self):
            return self.getTypedRuleContext(SIONParser.Si_falseContext,0)


        def getRuleIndex(self):
            return SIONParser.RULE_si_bool

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_bool" ):
                return visitor.visitSi_bool(self)
            else:
                return visitor.visitChildren(self)




    def si_bool(self):

        localctx = SIONParser.Si_boolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_si_bool)
        try:
            self.state = 97
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SIONParser.SI_true]:
                self.enterOuterAlt(localctx, 1)
                self.state = 95
                self.si_true()
                pass
            elif token in [SIONParser.SI_false]:
                self.enterOuterAlt(localctx, 2)
                self.state = 96
                self.si_false()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_trueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_true(self):
            return self.getToken(SIONParser.SI_true, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_true

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_true" ):
                return visitor.visitSi_true(self)
            else:
                return visitor.visitChildren(self)




    def si_true(self):

        localctx = SIONParser.Si_trueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_si_true)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(SIONParser.SI_true)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_falseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_false(self):
            return self.getToken(SIONParser.SI_false, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_false

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_false" ):
                return visitor.visitSi_false(self)
            else:
                return visitor.visitChildren(self)




    def si_false(self):

        localctx = SIONParser.Si_falseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_si_false)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(SIONParser.SI_false)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_nilContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_nil(self):
            return self.getToken(SIONParser.SI_nil, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_nil

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_nil" ):
                return visitor.visitSi_nil(self)
            else:
                return visitor.visitChildren(self)




    def si_nil(self):

        localctx = SIONParser.Si_nilContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_si_nil)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self.match(SIONParser.SI_nil)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_intContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_bin(self):
            return self.getToken(SIONParser.SI_bin, 0)

        def SI_oct(self):
            return self.getToken(SIONParser.SI_oct, 0)

        def SI_decimal(self):
            return self.getToken(SIONParser.SI_decimal, 0)

        def SI_hex(self):
            return self.getToken(SIONParser.SI_hex, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_int

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_int" ):
                return visitor.visitSi_int(self)
            else:
                return visitor.visitChildren(self)




    def si_int(self):

        localctx = SIONParser.Si_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_si_int)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SIONParser.SI_bin) | (1 << SIONParser.SI_oct) | (1 << SIONParser.SI_decimal) | (1 << SIONParser.SI_hex))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_dataContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_data(self):
            return self.getToken(SIONParser.SI_data, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_data

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_data" ):
                return visitor.visitSi_data(self)
            else:
                return visitor.visitChildren(self)




    def si_data(self):

        localctx = SIONParser.Si_dataContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_si_data)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self.match(SIONParser.SI_data)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_dateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def si_doubles(self):
            return self.getTypedRuleContext(SIONParser.Si_doublesContext,0)


        def si_ints(self):
            return self.getTypedRuleContext(SIONParser.Si_intsContext,0)


        def getRuleIndex(self):
            return SIONParser.RULE_si_date

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_date" ):
                return visitor.visitSi_date(self)
            else:
                return visitor.visitChildren(self)




    def si_date(self):

        localctx = SIONParser.Si_dateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_si_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.match(SIONParser.T__0)
            self.state = 112
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.state = 110
                self.si_doubles()
                pass

            elif la_ == 2:
                self.state = 111
                self.si_ints()
                pass


            self.state = 114
            self.match(SIONParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Si_stringContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SI_string_literal(self):
            return self.getToken(SIONParser.SI_string_literal, 0)

        def getRuleIndex(self):
            return SIONParser.RULE_si_string

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSi_string" ):
                return visitor.visitSi_string(self)
            else:
                return visitor.visitChildren(self)




    def si_string(self):

        localctx = SIONParser.Si_stringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_si_string)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self.match(SIONParser.SI_string_literal)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





